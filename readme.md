
# Network Attack Detection API using MLP

This project implements a machine learning model (Multi-Layer Perceptron) to detect network attacks based on flow data. It includes scripts for training the model, deploying it as a Flask web API, and interacting with the API using a client script.

## Project Overview

The goal of this project is to automatically detect network attacks by analyzing network flow data. A machine learning model is trained on labeled data and then exposed via a web API, allowing other applications or systems to send flow data and receive a prediction about whether it constitutes normal traffic or a specific type of attack ('None', 'Denial of Service', 'Port Scanning', 'Malware').

## Features

*   Loads network flow data from CSV files (`train_net.csv`, `test_net.csv`).
*   Performs data preprocessing, including handling missing values.
*   Selects relevant features using Random Forest feature importance.
*   Trains a Multi-Layer Perceptron (MLP) classifier.
*   Saves the trained model, data scaler, and feature list using `joblib`.
*   Provides a Flask-based web API (`/predict` endpoint) for making predictions.
*   API endpoint accepts JSON input containing network flow features.
*   API endpoint returns JSON output with the predicted class and class probabilities.
*   Includes an interactive client script for testing the API with samples from the training data.
*   Customized server-side terminal output (colorized predictions/errors, suppressed success logs).

## File Structure

```
.
├── train_net.csv             # Training dataset (Required)
├── test_net.csv              # Testing dataset (Used by training script)
├── models.py                 # Script to train the MLP model and save components
├── server.py                 # Flask web server application (API)
├── client.py                 # Interactive client to test the API
├── mlp_model.joblib          # Saved trained MLP model (Generated by models.py)
├── scaler.joblib             # Saved data scaler (Generated by models.py)
├── model_columns.joblib      # Saved list of features used by model (Generated by models.py)
├── requirements.txt          # List of Python dependencies (Create if needed)
└── README.md                 # This file
```

## Setup and Installation

1.  **Clone the Repository (if applicable):**
    ```bash
    git clone <your-repository-url>
    cd <repository-directory>
    ```
2.  **Create a Virtual Environment (Recommended):**
    ```bash
    python -m venv venv
    # On Windows:
    .\venv\Scripts\activate
    # On macOS/Linux:
    source venv/bin/activate
    ```
3.  **Install Dependencies:**
    *(Create a `requirements.txt` file first if needed: `pip freeze > requirements.txt`)*
    ```bash
    pip install -r requirements.txt
    ```
    *(Or install manually):*
    ```bash
    pip install Flask joblib pandas numpy scikit-learn requests matplotlib seaborn
    ```
4.  **Place Data Files:**
    Ensure `train_net.csv` and `test_net.csv` are present in the root project directory.

## Usage

**Step 1: Train the Model and Save Components**
*   Run the training script once. This will preprocess data, train the MLP, evaluate it, and generate the essential `.joblib` files needed by the server.
    ```bash
    python models.py
    ```
*   Verify that `mlp_model.joblib`, `scaler.joblib`, and `model_columns.joblib` are created.

**Step 2: Run the Flask API Server**
*   Start the server in a terminal. It will load the `.joblib` files.
    ```bash
    python server.py
    ```
*   The server will print startup messages and then wait silently. It will only print further messages for errors or successful predictions (colorized). Keep this terminal running.

**Step 3: Run the Interactive Client**
*   Open a **second terminal window** in the same project directory.
*   Make sure the virtual environment is activated (if used).
*   Run the client script:
    ```bash
    python client.py
    ```
*   Follow the interactive menu prompts to test the API with samples from the training data.
*   Observe the output in the client terminal (analysis, probabilities, match status).
*   Observe the server terminal for the colorized prediction confirmations (e.g., `--- Attack Detected: [91mMalware[0m ---`).

## Results Summary (Based on Validation Set in `models.py`)

*   **Overall Accuracy:** High (~99%), but potentially misleading due to class imbalance.
*   **Strong Performance:** 'None' and 'Port Scanning' classes were detected accurately.
*   **Weak Performance:** 'Denial of Service' detection showed poor recall (~65%), indicating many missed attacks.
*   **Unreliable Performance:** 'Malware' detection results were unreliable due to extremely low sample counts in the likely training/validation split.

## Known Limitations & Future Work

*   The current model struggles with minority classes ('Denial of Service', 'Malware') due to class imbalance.
*   The API is basic and lacks advanced features (authentication, rate limiting, etc.).
*   Hyperparameter tuning for the MLP was not performed.
*   **Recommendations:** Address class imbalance (SMOTE, class weights), tune hyperparameters, try different models (Random Forest, XGBoost), improve feature engineering/selection, acquire more diverse data (especially for attacks).
